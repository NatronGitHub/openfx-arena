/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "BlackmagicRawAPIDispatch.h"

#include <windows.h>		// Mutex functions, LoadLibrary functions, CoInitializeEx etc.
#include <algorithm>		// std::replace
#include <string>			// std::wstring

#define kBlackmagicRawAPI_LibraryName	L"BlackmagicRawAPI.dll"
#define kBlackmagicRawAPI_LibraryFolder	L"BlackmagicRawAPI"

class BmdMutex
{
public:
	inline explicit BmdMutex() { m_mutex = CreateMutex(NULL, FALSE, NULL); }
	inline ~BmdMutex() { CloseHandle (m_mutex); }
	inline void lock() { WaitForSingleObject(m_mutex, INFINITE); }
	inline void unlock() { ReleaseMutex(m_mutex); }

private:
	HANDLE m_mutex;
};

class BmdScopedLock
{
public:
	inline explicit BmdScopedLock(BmdMutex& mutex) : m_mutex(mutex) { m_mutex.lock(); }
	inline ~BmdScopedLock() { m_mutex.unlock(); }

private:
	BmdMutex& m_mutex;
};

typedef IBlackmagicRawFactory* (*CreateRawFactoryFunc)(void);

static BmdMutex				gBlackmagicRawMutex;
static HMODULE				gManuallyLoadedDLLHandle				= NULL;
static CreateRawFactoryFunc	gCreateBlackmagicRawFactoryInstance		= NULL;

static void TryLoadBlackmagicRawAPI(const std::wstring& libraryFilePath)
{
	gManuallyLoadedDLLHandle = LoadLibraryExW(libraryFilePath.c_str(), NULL, 0);
	if (gManuallyLoadedDLLHandle != NULL)
	{
		gCreateBlackmagicRawFactoryInstance = (CreateRawFactoryFunc)GetProcAddress(gManuallyLoadedDLLHandle, "CreateBlackmagicRawFactoryInstance");
		if (gCreateBlackmagicRawFactoryInstance == NULL)
		{
			FreeLibrary(gManuallyLoadedDLLHandle);
			gManuallyLoadedDLLHandle = NULL;
		}
	}
}

static std::wstring PathFromBSTR(BSTR loadPath)
{
	std::wstring libraryPath(loadPath);

	// Converts any forward slashes to backslashes
	std::replace(libraryPath.begin(), libraryPath.end(), L'/', L'\\');

	// Ensure the path ends in a slash
	if (! libraryPath.empty() && ! (libraryPath.back() == L'\\'))
		libraryPath += L'\\';

	return libraryPath;
}

IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstance (void)
{
	IBlackmagicRawFactory* factory = NULL;

	if (gCreateBlackmagicRawFactoryInstance == NULL)
	{
		BSTR libraryFolder = SysAllocString(kBlackmagicRawAPI_LibraryFolder);
		factory = CreateBlackmagicRawFactoryInstanceFromExeRelativePath(libraryFolder);
		SysFreeString(libraryFolder);
		if (factory != NULL)
			return factory;
	}

	if (gCreateBlackmagicRawFactoryInstance == NULL)
	{
		factory = CreateBlackmagicRawFactoryInstanceFromExeRelativePath(NULL);
		if (factory != NULL)
			return factory;
	}

	BmdScopedLock lock(gBlackmagicRawMutex);

	if (gCreateBlackmagicRawFactoryInstance == NULL)
		return NULL;

	return gCreateBlackmagicRawFactoryInstance();
}

IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstanceFromPath (BSTR loadPath)
{
	BmdScopedLock lock(gBlackmagicRawMutex);

	if ((loadPath != NULL) && (gCreateBlackmagicRawFactoryInstance == NULL))
	{
		// Convert the BSTR to a santised std::wstring path
		std::wstring libraryFilePath(PathFromBSTR(loadPath));

		TryLoadBlackmagicRawAPI(libraryFilePath + kBlackmagicRawAPI_LibraryName);
	}

	if (gCreateBlackmagicRawFactoryInstance == NULL)
		return NULL;

	return gCreateBlackmagicRawFactoryInstance();
}

IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstanceFromExeRelativePath (BSTR relativePath)
{
	BmdScopedLock lock(gBlackmagicRawMutex);

	if (gCreateBlackmagicRawFactoryInstance == NULL)
	{
		HMODULE callingModuleHandle = GetModuleHandle(NULL);
		if (callingModuleHandle == NULL)
			return NULL;

		wchar_t moduleFileName[MAX_PATH + 1];
		if (GetModuleFileNameW(callingModuleHandle, moduleFileName, MAX_PATH) == 0)
			return NULL;

		moduleFileName[MAX_PATH] = '\0';

		wchar_t drive[_MAX_DRIVE + 1];
		wchar_t directory[_MAX_DIR + 1];

		errno_t retVal = _wsplitpath_s(
			moduleFileName,
			drive,
			_MAX_DRIVE,
			directory,
			_MAX_DIR,
			NULL,		// ignore file name
			0,
			NULL,    	// ignore file extension
			0
		);

		if (retVal != 0)
			return nullptr;

		// Convert the BSTR to a santised std::wstring path
		std::wstring libraryFilePath;
		libraryFilePath += drive;
		libraryFilePath += directory;

		if (relativePath != NULL)
		{
			libraryFilePath += PathFromBSTR(relativePath);
		}

		TryLoadBlackmagicRawAPI(libraryFilePath + kBlackmagicRawAPI_LibraryName);
    }

	if (gCreateBlackmagicRawFactoryInstance == NULL)
		return NULL;

	return gCreateBlackmagicRawFactoryInstance();
}